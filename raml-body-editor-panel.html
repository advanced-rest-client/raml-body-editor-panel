<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-tabs/paper-tab.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../code-mirror/code-mirror.html">
<link rel="import" href="../vertical-tabs/vertical-tabs.html">
<link rel="import" href="../body-json-editor/body-json-editor.html">
<link rel="import" href="../body-form-editor/body-form-editor.html">
<link rel="import" href="cm-arc-styles.html">
<!--
`<raml-body-editor-panel>` A body editor panel containin JSON, XML and form editors.

It is meant to work with the RAML spec. However without it, it will work as a CodeMirror editor.

### Example
```
<raml-body-editor-panel></raml-body-editor-panel>
```

### Styling
`<raml-body-editor-panel>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--raml-body-editor-panel` | Mixin applied to the element | `{}`

Use `paper-tabs` and `code-mirror` variables to style this elements.

@group RAML Elements
@element raml-body-editor-panel
@demo demo/index.html
-->
<dom-module id="raml-body-editor-panel">
  <template>
    <style>
     :host {
      display: block;

      @apply(--raml-body-editor-panel);

      --code-mirror-wrapper: {
        display: block;
        height: 100%;
      };

      --code-mirror-editor: {
        z-index: 0;
        display: block;
      }

      --paper-tabs-content: {
        overflow: auto;
      }
    }
    </style>
    <vertical-tabs selected="{{selected}}" on-iron-select="_tabChangedHandler" attr-for-selected="data-editor">
      <paper-tab data-editor="json"  hidden$="[[!isJson]]">JSON</paper-tab>
      <!-- <paper-tab  data-editor="xml" hidden$="[[!isXml]]">XML</paper-tab> -->
      <paper-tab data-editor="form"  hidden$="[[!isForm]]">Form</paper-tab>
      <paper-tab data-editor="code-mirror" >Raw data</paper-tab>
      <iron-pages data-editor="code-mirror"  content selected="{{selected}}" attr-for-selected="data-editor">
        <body-json-editor data-editor="json" narrow="[[narrow]]" value="{{_valueJson}}" type="[[selectedType]]" opened="[[_computeEditorOpened(selected, 0)]]" hidden$="[[!isJson]]"></body-json-editor>
        <!-- <body-xml-editor data-editor="xml"  value="{{_valueXml}}" type="[[selectedType]]" opened="[[_computeEditorOpened(selected, 1)]]" hidden$="[[!isXml]]">XML</body-xml-editor> -->
        <body-form-editor data-editor="form"  value="{{_valueForm}}" type="[[selectedType]]" opened="[[_computeEditorOpened(selected, 2)]]" hidden$="[[!isForm]]"></body-form-editor>
        <div class="cm-tab-editor" data-editor="code-mirror" >
          <template is="dom-if" if="[[_computeHasMany(mimeTypes)]]">
            <paper-dropdown-menu label="Select content type">
              <paper-listbox class="dropdown-content" attr-for-selected="data-mime" selected="{{contentType}}">
                <template is="dom-repeat" items="[[mimeTypes]]">
                  <paper-item data-mime$="[[item]]">[[item]]</paper-item>
                </template>
              </paper-listbox>
            </paper-dropdown-menu>
          </template>
          <code-mirror opened="[[_computeEditorOpened(selected, 3)]]" mode="[[cmMode]]" value="{{_valueCodeMirror}}" theme="cm-arc"></code-mirror>
        </div>
      </iron-pages>
    </vertical-tabs>
  </template>
  <script>
  Polymer({
    is: 'raml-body-editor-panel',
    /**
     * Fires when the value change.
     *
     * @event body-value-changed
     * @param {String} value Current editor value
     */
    properties: {
      // Selected tab.
      selected: {
        type: String,
        value: 'json'
      },
      // Sets and gets the editor value.
      value: {
        type: String,
        value: '{\n\t\n}',
        notify: true
      },
      // Code mirror mode. See `<code-mirror>` docs for more information.
      // This is computed from the content type property.
      cmMode: {
        type: String,
        value: 'application/json',
        computed: '_computeCmMode(contentType)'
      },
      /**
       * When set it will attempt to run associated code mirror mode.
       * This element listens for the `content-type-changed` event and when
       * handled it will automatically update content type and `mode`.
       * If this value is set than it will override code-mirror `mode`
       * until this value change.
       *
       * Also, this property notifies parent element about the change. It may be changed by the
       * element when the user start filling the body panel for particular content type and
       * the type is not the once that is set.
       * The use case is when a RAML method has more than one body defined (xml and json for
       * example) and the default is JSON but the user switch to the xml form and start filling it.
       * Then the content type must be changed to `application/xml`. The `content-type-changed`
       * will be fired as well in this case.
       */
      contentType: {
        type: String,
        notify: true
      },
      /**
       * Body definition from the RAML file.
       * It should be array of the body types.
       * It expects to have expanded types (so there's no sub-types). This can be done by using
       * the `<raml-js-parser>` element which expands the types definition.
       *
       * When set then the editor will show only forms for correstponding types that are available
       * for the method.
       */
      body: {
        type: Array,
        observer: '_bodyChanged'
      },
      /**
       * The mime types found in the `body` array.
       */
      mimeTypes: {
        type: Array,
        readOnly: true,
        observer: '_mimeTypesChanged'
      },
      // True if this method can have the XML editor
      isXml: {
        type: Boolean,
        readOnly: true,
        value: false
      },
      // True if this method can have the Form editor
      isForm: {
        type: Boolean,
        readOnly: true,
        value: false
      },
      // True if this method can have the JSON editor
      isJson: {
        type: Boolean,
        readOnly: true,
        value: false
      },
      /**
       * A RAML's type definition
       * A JSON editor uses it to create a schema definition (as a JSON object of {name: type}) to
       * display autosuggestions.
       */
      selectedType: {
        type: Object,
        computed: '_computeSelectedType(contentType, body)'
      },
      // Internal value of the CodeMirror editor.
      _valueCodeMirror: String,
      // Internal value of the JSON editor.
      _valueJson: String,
      // Internal value of the XML editor.
      _valueForm: String,
      // Internal value of the Form editor.
      _valueXml: String,
      // Currenlty selected editor.
      _selectedEditor: String,
      // if set it will display narrow (mobile) layout.
      narrow: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_valueChanged(value)',
      '_editorValueChanged(_selectedEditor, "code-mirror", _valueCodeMirror)',
      '_editorValueChanged(_selectedEditor, "json", _valueJson)',
      '_editorValueChanged(_selectedEditor, "form", _valueForm)',
      '_editorValueChanged(_selectedEditor, "xml", _valueXml)'
    ],

    attached: function() {
      this.listen(window, 'content-type-changed', '_ctHandler');
    },

    detached: function() {
      this.unlisten(window, 'content-type-changed', '_ctHandler');
    },

    ready: function() {
      this._isReady = true;
    },

    /**
     * Synchronize ditors values if the synchronization is possible.
     * For example code mirror's value will be always updated if other editor is the source.
     *
     * This will not synchronize the value between other editors. This synchronization is
     * made when the tab is changing.
     *
     * If the content type is not corresponding with the source then the content type header
     * value will be changed.
     */
    _editorValueChanged: function(selected, source, value) {
      if (selected !== source) {
        return;
      }
      this.set('value', value);
      if (selected !== 'code-mirror') {
        this._valueCodeMirror = value;
      }
      this._updateContentTypeFromSelectedEditor();
    },
    /**
     * Updates the `contentType` property depending on the selected editor if needed.
     *
     * @param {String} selected Selected editor name.
     */
    _updateContentTypeFromSelectedEditor: function(selected) {
      var _contentType;
      var ct = this.contentType;
      if (selected === 'json' && this.isJson && ct !== 'application/json') {
        _contentType = 'application/json';
      }
      if (selected === 'xml' && this.isXml && ct !== 'application/xml') {
        _contentType = 'application/xml';
      }
      if (selected === 'form' && this.isForm && ct !== 'application/x-www-form-urlencoded') {
        _contentType = 'application/x-www-form-urlencoded';
      }
      if (_contentType) {
        this.fire('content-type-changed', {
          value: _contentType
        });
      }
    },

    // Refreshes the code mirror editor when its tab is displayed.
    _tabChangedHandler: function(e) {
      if (!this._isReady) {
        return;
      }
      if (!e.detail.item || !e.detail.item.classList) {
        return;
      }
      var newSelected;
      if (e.detail.item.classList.contains('cm-tab-editor')) {
        this.$$('code-mirror').editor.refresh();
        newSelected = 'code-mirror';
      } else {
        var name = e.detail.item.nodeName.toLowerCase();
        if (name === 'body-json-editor') {
          newSelected = 'json';
        } else if (name === 'body-xml-editor') {
          newSelected = 'xml';
        } else if (name === 'body-form-editor') {
          newSelected = 'form';
        }
      }
      if (!newSelected) {
        // Event comes from the child element of the paper tabs.
        return;
      }
      if (this._ensureTabsSelected()) {
        this._updateContentTypeFromSelectedEditor(this.selected);
      }
      this._syncValuesOnTabChange(this.selected, this._selectedEditor);
      this._selectedEditor = this.selected;
    },
    /**
     * Because tabs are dynamically hidden from the view the element must calculate
     * if proper tabs is selected at the moment.
     * This will select first tab that is not hidden.
     */
    _ensureTabsSelected: function() {
      var ij = this.isJson;
      var ifo = this.isForm;
      var ix = this.isXml;
      var sel = this.selected;
      if (sel === 'json' && !ij) {
        // TODO: Unhash when XML ready
        // if (this.ix) {
        //   this.selected = 'xml';
        //   return true;
        // } else
        if (ifo) {
          this.selected = 'form';
          return true;
        } else {
          this.selected = 'code-mirror';
          return true;
        }
      } else if (sel === 'xml' && !ix) {
        if (ij) {
          this.selected = 'json';
          return true;
        } else if (ifo) {
          this.selected = 'form';
          return true;
        } else {
          this.selected = 'code-mirror';
          return true;
        }
      } else if (sel === 'form' && !ifo) {
        if (ij) {
          this.selected = 'json';
          return true;
          // } else if (ix) {
          //   this.selected = 'xml';
          //   return true;
        } else {
          this.selected = 'code-mirror';
          return true;
        }
      } else if (!ix && !ij && !ifo) {
        this.selected = 'code-mirror';
        return true;
      }
      return false;
    },

    /**
     * Sunchronizes values between editors on tab change event.
     * This will only performs a synchronization from code mirror to other editors.
     * Never between other editors or there will be data incompatibility.
     *
     * @param {String} selected New selected tab
     * @param {String} oldSelected Old selected tab
     */
    _syncValuesOnTabChange: function(selected, oldSelected) {
      if (!selected || oldSelected === selected) {
        return;
      }
      if (oldSelected === 'code-mirror') {
        // take a value from the code mirror editor and set a value on the new selected editor
        if (selected === 'json') {
          this._valueJson = this._valueCodeMirror;
        } else if (selected === 'xml') {
          this._valueXml = this._valueCodeMirror;
        } else if (selected === 'form') {
          this._valueForm = this._valueCodeMirror;
        }
      }
    },

    // Handler for content type changed event.
    _ctHandler: function(e, detail) {
      if (!detail || !detail.value) {
        return;
      }
      this.set('contentType', detail.value);
    },
    // Computes to CodeMirror mode based on the content type.
    _computeCmMode: function(contentType) {
      return contentType;
    },
    // Fires the `body-value-changed` event when the value has changed.
    _valueChanged: function(value) {
      this.fire('body-value-changed', {
        value: value
      });
    },
    // Cleaning of the variables when the body change
    _cleanBodySettings: function() {
      this._setMimeTypes(undefined);
      this._setIsXml(false);
      this._setIsJson(false);
      this._setIsForm(false);
    },
    /**
     * Called when `body` array change to set up the `mimeTypes` array.
     */
    _bodyChanged: function(body) {
      this._cleanBodySettings();
      if (!body || !(body instanceof Array)) {
        return;
      }
      var mimes = body.map(function(item) {
        return item.key;
      });
      this._setMimeTypes(mimes);
      if (mimes && mimes.length) {
        this.fire('content-type-changed', {
          value: mimes[0]
        });
      }
    },
    /**
     * Chandler to the `mimeTypes` array change.
     * It will display / hide editors depending on the mime types defined in the RAML definiotion.
     * By default only CodeMirror editor is visible. Other editors depends on the spec.
     */
    _mimeTypesChanged: function(mimes) {
      if (!mimes) {
        return;
      }

      var isXml = false;
      var isForm = false;
      var isJson = false;

      for (var i = 0, len = mimes.length; i < len; i++) {
        if (!isJson && mimes[i].indexOf('json') !== -1) {
          isJson = true;
        } else if (!isXml && mimes[i].indexOf('xml') !== -1) {
          isXml = true;
        } else if (!isForm && mimes[i].indexOf('x-www-form-urlencoded') !== -1) {
          isForm = true;
        }
      }
      this._setIsXml(isXml);
      this._setIsJson(isJson);
      this._setIsForm(isForm);

      if (mimes[0] !== this.contentType) {
        this._selectMimeType(mimes[0]);
      }
      this.$$('vertical-tabs').notifyResize();
    },
    // Computes if given argument is an array and has more than one item.
    _computeHasMany: function(arr) {
      return (arr && arr instanceof Array) ? arr.length > 1 : false;
    },
    // Sets given `mime` type as a current content type value.
    _selectMimeType: function(mime) {
      this.fire('content-type-changed', {
        value: mime
      });
    },
    // Computes if the editor is selected editor in the view
    _computeEditorOpened: function(selected, index) {
      return selected === index;
    },
    /**
     * Computes the `selectedType` property that is passed to the editors.
     * Editors uses it to display autocomplete feature.
     */
    _computeSelectedType: function(mimeType, body) {
      if (!mimeType || !body || !body.length) {
        return;
      }
      return this._getBodyForMime(mimeType, body);
    },
    /**
     * Returns a body definition object for given `mime`.
     *
     * @param {String} mime The mime type of the body.
     * @param {Array?} body The list of body definition. If not set then `this.body` will be used
     * @param {Object|undefined} A body definition or undefined if not found.
     */
    _getBodyForMime: function(mime, body) {
      body = body || this.body;
      if (!mime || !body || !body.length) {
        return;
      }
      for (var i = 0, len = body.length; i < len; i++) {
        if (body[i].key === mime) {
          return body[i];
        }
      }
    }
  });
  </script>
</dom-module>
